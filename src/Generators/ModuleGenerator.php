<?php

declare(strict_types=1);

namespace Grazulex\LaravelTurbomaker\Generators;

use Exception;
use Grazulex\LaravelTurbomaker\Adapters\ModelSchemaGenerationAdapter;
use Grazulex\LaravelTurbomaker\Schema\Schema;

/**
 * ModuleGenerator Enterprise - 100% ModelSchema Powered
 * Uses ModelSchema Fragment Architecture for maximum performance and enterprise features
 * NO LEGACY FALLBACK - Pure ModelSchema Enterprise Power!
 */
final class ModuleGenerator
{
    private ModelSchemaGenerationAdapter $adapter;

    public function __construct(?ModelSchemaGenerationAdapter $adapter = null)
    {
        $this->adapter = $adapter ?? new ModelSchemaGenerationAdapter();
    }

    /**
     * Generate module using PURE ModelSchema Enterprise Architecture
     * NO FALLBACK - ModelSchema Enterprise or nothing!
     *
     * @param  string  $name  The model name
     * @param  array  $options  Generation options, including 'write_files' for test compatibility
     * @param  Schema|null  $schema  Optional TurboMaker schema
     * @return array Generated file paths or simulated paths
     */
    public function generate(string $name, array $options = [], ?Schema $schema = null): array
    {
        // Use ModelSchema Enterprise GenerationService::generateAll() - THE ENTERPRISE WAY!
        return $this->generateWithModelSchema($name, $options, $schema);
    }

    /**
     * Generate module with actual file writing (for test compatibility)
     * This enables the hybrid approach when needed
     */
    public function generateWithFiles(string $name, array $options = [], ?Schema $schema = null): array
    {
        // Force file writing for test compatibility
        $options['write_files'] = true;

        return $this->generateWithModelSchema($name, $options, $schema);
    }

    /**
     * Get available ModelSchema Enterprise generators
     */
    public function getAvailableGenerators(): array
    {
        return $this->adapter->getAvailableGenerators();
    }

    /**
     * Get available generator names from ModelSchema
     */
    public function getAvailableGeneratorNames(): array
    {
        return $this->adapter->getAvailableGeneratorNames();
    }

    /**
     * Generate specific component using ModelSchema Enterprise
     */
    public function generateSpecific(string $name, string $type, array $options = [], ?Schema $schema = null): array
    {
        $mappedOptions = $this->mapOptionsForModelSchema($options);

        return $this->adapter->generate($name, $type, $mappedOptions, $schema);
    }

    /**
     * Generate multiple components using ModelSchema Fragment Architecture
     */
    public function generateMultiple(string $name, array $generators, array $options = [], ?Schema $schema = null): array
    {
        $mappedOptions = $this->mapOptionsForModelSchema($options);

        return $this->adapter->generateMultiple($name, $generators, $mappedOptions, $schema);
    }

    /**
     * Get the ModelSchema GenerationService directly for advanced features
     */
    public function getModelSchemaService(): ModelSchemaGenerationAdapter
    {
        return $this->adapter;
    }

    /**
     * Generate using ModelSchema Enterprise GenerationService::generateAll()
     * ðŸš€ PURE ENTERPRISE POWER - 9 Generators + Fragment Architecture
     */
    private function generateWithModelSchema(string $name, array $options, ?Schema $schema): array
    {
        // Map generation options for ModelSchema Enterprise
        $mappedOptions = $this->mapOptionsForModelSchema($options);

        // ðŸ”¥ Use ModelSchema GenerationService::generateAll() - NO COMPROMISE!
        $results = $this->adapter->generateAll($name, $mappedOptions, $schema);

        // Convert to TurboMaker expected format for compatibility
        return $this->formatResultsForTurboMaker($results, $name);
    }

    /**
     * Map TurboMaker options to ModelSchema Enterprise options
     */
    private function mapOptionsForModelSchema(array $options): array
    {
        return [
            // Core components (always generated by ModelSchema)
            'model' => true,
            'migration' => true,

            // Optional components with TurboMaker compatibility
            'requests' => $options['generate_requests'] ?? $options['requests'] ?? true,
            'resources' => $options['generate_api_resources'] ?? $options['resources'] ?? true,
            'factory' => $options['generate_factory'] ?? $options['factory'] ?? true,
            'seeder' => $options['generate_seeder'] ?? $options['seeder'] ?? false,
            'controllers' => true, // ModelSchema generates both API and Web controllers
            'tests' => $options['generate_tests'] ?? $options['tests'] ?? true, // ModelSchema generates Feature + Unit
            'policies' => $options['generate_policies'] ?? $options['policies'] ?? false,

            // New ModelSchema Enterprise generators (v0.0.3)
            'observers' => $options['generate_observers'] ?? $options['observers'] ?? false,
            'services' => $options['generate_services'] ?? $options['services'] ?? false,
            'actions' => $options['generate_actions'] ?? $options['actions'] ?? false,
            'rules' => $options['generate_rules'] ?? $options['rules'] ?? false,

            // Enterprise features
            'force' => $options['force'] ?? false,
            'enhanced' => true, // Always use ModelSchema enterprise features
            'fragments' => $options['fragments'] ?? false, // Fragment Architecture
            'optimize' => $options['optimize'] ?? false, // YamlOptimization

            // Generation modes
            'api_only' => $options['api_only'] ?? false,
            'web_only' => ! ($options['api_only'] ?? false),

            // Hybrid mode: Fragment Architecture + File Writing
            'write_files' => $options['write_files'] ?? false, // For test compatibility

            // Preserve relationships for TurboMaker-specific processing
            'belongs_to' => $options['belongs_to'] ?? [],
            'has_many' => $options['has_many'] ?? [],
            'has_one' => $options['has_one'] ?? [],
        ];
    }

    /**
     * Format ModelSchema results for TurboMaker compatibility
     */
    private function formatResultsForTurboMaker(array $results, string $name): array
    {
        $formatted = [];

        foreach ($results as $type => $paths) {
            if (is_array($paths) && $paths !== []) {
                $formatted[$type] = $paths;
            }
        }

        // Ensure we have the expected structure
        if ($formatted === []) {
            throw new Exception("ModelSchema Enterprise failed to generate files for: {$name}");
        }

        return $formatted;
    }
}
